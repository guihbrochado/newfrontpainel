import {
  __commonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/string-hash/index.js
var require_string_hash = __commonJS({
  "node_modules/string-hash/index.js"(exports, module) {
    "use strict";
    function hash(str) {
      var hash2 = 5381, i = str.length;
      while (i) {
        hash2 = hash2 * 33 ^ str.charCodeAt(--i);
      }
      return hash2 >>> 0;
    }
    module.exports = hash;
  }
});

// node_modules/asap/browser-raw.js
var require_browser_raw = __commonJS({
  "node_modules/asap/browser-raw.js"(exports, module) {
    "use strict";
    module.exports = rawAsap;
    function rawAsap(task) {
      if (!queue.length) {
        requestFlush();
        flushing = true;
      }
      queue[queue.length] = task;
    }
    var queue = [];
    var flushing = false;
    var requestFlush;
    var index = 0;
    var capacity = 1024;
    function flush() {
      while (index < queue.length) {
        var currentIndex = index;
        index = index + 1;
        queue[currentIndex].call();
        if (index > capacity) {
          for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }
          queue.length -= index;
          index = 0;
        }
      }
      queue.length = 0;
      index = 0;
      flushing = false;
    }
    var scope = typeof global !== "undefined" ? global : self;
    var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
    if (typeof BrowserMutationObserver === "function") {
      requestFlush = makeRequestCallFromMutationObserver(flush);
    } else {
      requestFlush = makeRequestCallFromTimer(flush);
    }
    rawAsap.requestFlush = requestFlush;
    function makeRequestCallFromMutationObserver(callback) {
      var toggle = 1;
      var observer = new BrowserMutationObserver(callback);
      var node = document.createTextNode("");
      observer.observe(node, { characterData: true });
      return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
      };
    }
    function makeRequestCallFromTimer(callback) {
      return function requestCall() {
        var timeoutHandle = setTimeout(handleTimer, 0);
        var intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
          clearTimeout(timeoutHandle);
          clearInterval(intervalHandle);
          callback();
        }
      };
    }
    rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
  }
});

// node_modules/asap/browser-asap.js
var require_browser_asap = __commonJS({
  "node_modules/asap/browser-asap.js"(exports, module) {
    "use strict";
    var rawAsap = require_browser_raw();
    var freeTasks = [];
    var pendingErrors = [];
    var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
    function throwFirstError() {
      if (pendingErrors.length) {
        throw pendingErrors.shift();
      }
    }
    module.exports = asap2;
    function asap2(task) {
      var rawTask;
      if (freeTasks.length) {
        rawTask = freeTasks.pop();
      } else {
        rawTask = new RawTask();
      }
      rawTask.task = task;
      rawAsap(rawTask);
    }
    function RawTask() {
      this.task = null;
    }
    RawTask.prototype.call = function() {
      try {
        this.task.call();
      } catch (error) {
        if (asap2.onerror) {
          asap2.onerror(error);
        } else {
          pendingErrors.push(error);
          requestErrorThrow();
        }
      } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
      }
    };
  }
});

// node_modules/aphrodite/es/chunk-febce46b.js
var import_string_hash = __toESM(require_string_hash());
var import_asap = __toESM(require_browser_asap());
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
    return arr2;
  }
}
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
var UPPERCASE_RE = /([A-Z])/g;
var UPPERCASE_RE_TO_KEBAB = function UPPERCASE_RE_TO_KEBAB2(match) {
  return (
    /* : string */
    "-".concat(match.toLowerCase())
  );
};
var kebabifyStyleName = function kebabifyStyleName2(string) {
  var result = string.replace(UPPERCASE_RE, UPPERCASE_RE_TO_KEBAB);
  if (result[0] === "m" && result[1] === "s" && result[2] === "-") {
    return "-".concat(result);
  }
  return result;
};
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridColumn: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}
var prefixes = ["Webkit", "ms", "Moz", "O"];
Object.keys(isUnitlessNumber).forEach(function(prop) {
  prefixes.forEach(function(prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});
var stringifyValue = function stringifyValue2(key, prop) {
  if (typeof prop === "number") {
    if (isUnitlessNumber[key]) {
      return "" + prop;
    } else {
      return prop + "px";
    }
  } else {
    return "" + prop;
  }
};
var stringifyAndImportantifyValue = function stringifyAndImportantifyValue2(key, prop) {
  return (
    /* : string */
    importantify(stringifyValue(key, prop))
  );
};
var hashString = function hashString2(string, key) {
  return (
    /* string */
    (0, import_string_hash.default)(string).toString(36)
  );
};
var hashObject = function hashObject2(object) {
  return (
    /* : string */
    hashString(JSON.stringify(object))
  );
};
var importantify = function importantify2(string) {
  return (
    /* : string */
    // Bracket string character access is very fast, and in the default case we
    // normally don't expect there to be "!important" at the end of the string
    // so we can use this simple check to take an optimized path. If there
    // happens to be a "!" in this position, we follow up with a more thorough
    // check.
    string[string.length - 10] === "!" && string.slice(-11) === " !important" ? string : "".concat(string, " !important")
  );
};
var MAP_EXISTS = typeof Map !== "undefined";
var OrderedElements = function() {
  function OrderedElements2() {
    this.elements = {};
    this.keyOrder = [];
  }
  var _proto = OrderedElements2.prototype;
  _proto.forEach = function forEach(callback) {
    for (var i = 0; i < this.keyOrder.length; i++) {
      callback(this.elements[this.keyOrder[i]], this.keyOrder[i]);
    }
  };
  _proto.set = function set(key, value, shouldReorder) {
    if (!this.elements.hasOwnProperty(key)) {
      this.keyOrder.push(key);
    } else if (shouldReorder) {
      var index = this.keyOrder.indexOf(key);
      this.keyOrder.splice(index, 1);
      this.keyOrder.push(key);
    }
    if (value == null) {
      this.elements[key] = value;
      return;
    }
    if (MAP_EXISTS && value instanceof Map || value instanceof OrderedElements2) {
      var nested = this.elements.hasOwnProperty(key) ? this.elements[key] : new OrderedElements2();
      value.forEach(function(value2, key2) {
        nested.set(key2, value2, shouldReorder);
      });
      this.elements[key] = nested;
      return;
    }
    if (!Array.isArray(value) && _typeof(value) === "object") {
      var _nested = this.elements.hasOwnProperty(key) ? this.elements[key] : new OrderedElements2();
      var keys = Object.keys(value);
      for (var i = 0; i < keys.length; i += 1) {
        _nested.set(keys[i], value[keys[i]], shouldReorder);
      }
      this.elements[key] = _nested;
      return;
    }
    this.elements[key] = value;
  };
  _proto.get = function get(key) {
    return this.elements[key];
  };
  _proto.has = function has(key) {
    return this.elements.hasOwnProperty(key);
  };
  _proto.addStyleType = function addStyleType(styleType) {
    var _this = this;
    if (MAP_EXISTS && styleType instanceof Map || styleType instanceof OrderedElements2) {
      styleType.forEach(function(value, key) {
        _this.set(key, value, true);
      });
    } else {
      var keys = Object.keys(styleType);
      for (var i = 0; i < keys.length; i++) {
        this.set(keys[i], styleType[keys[i]], true);
      }
    }
  };
  return OrderedElements2;
}();
function unwrapExports(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
function getCjsExportFromNamespace(n) {
  return n && n.default || n;
}
var capitalizeString_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = capitalizeString;
  function capitalizeString(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
});
unwrapExports(capitalizeString_1);
var prefixProperty_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixProperty;
  var _capitalizeString2 = _interopRequireDefault(capitalizeString_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function prefixProperty(prefixProperties, property, style) {
    if (prefixProperties.hasOwnProperty(property)) {
      var newStyle = {};
      var requiredPrefixes = prefixProperties[property];
      var capitalizedProperty = (0, _capitalizeString2.default)(property);
      var keys = Object.keys(style);
      for (var i = 0; i < keys.length; i++) {
        var styleProperty = keys[i];
        if (styleProperty === property) {
          for (var j = 0; j < requiredPrefixes.length; j++) {
            newStyle[requiredPrefixes[j] + capitalizedProperty] = style[property];
          }
        }
        newStyle[styleProperty] = style[styleProperty];
      }
      return newStyle;
    }
    return style;
  }
});
unwrapExports(prefixProperty_1);
var prefixValue_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixValue;
  function prefixValue(plugins, property, value, style, metaData) {
    for (var i = 0, len = plugins.length; i < len; ++i) {
      var processedValue = plugins[i](property, value, style, metaData);
      if (processedValue) {
        return processedValue;
      }
    }
  }
});
unwrapExports(prefixValue_1);
var addNewValuesOnly_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addNewValuesOnly;
  function addIfNew(list, value) {
    if (list.indexOf(value) === -1) {
      list.push(value);
    }
  }
  function addNewValuesOnly(list, values) {
    if (Array.isArray(values)) {
      for (var i = 0, len = values.length; i < len; ++i) {
        addIfNew(list, values[i]);
      }
    } else {
      addIfNew(list, values);
    }
  }
});
unwrapExports(addNewValuesOnly_1);
var isObject_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isObject;
  function isObject(value) {
    return value instanceof Object && !Array.isArray(value);
  }
});
unwrapExports(isObject_1);
var createPrefixer_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createPrefixer2;
  var _prefixProperty2 = _interopRequireDefault(prefixProperty_1);
  var _prefixValue2 = _interopRequireDefault(prefixValue_1);
  var _addNewValuesOnly2 = _interopRequireDefault(addNewValuesOnly_1);
  var _isObject2 = _interopRequireDefault(isObject_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function createPrefixer2(_ref) {
    var prefixMap = _ref.prefixMap, plugins = _ref.plugins;
    return function prefix(style) {
      for (var property in style) {
        var value = style[property];
        if ((0, _isObject2.default)(value)) {
          style[property] = prefix(value);
        } else if (Array.isArray(value)) {
          var combinedValue = [];
          for (var i = 0, len = value.length; i < len; ++i) {
            var processedValue = (0, _prefixValue2.default)(plugins, property, value[i], style, prefixMap);
            (0, _addNewValuesOnly2.default)(combinedValue, processedValue || value[i]);
          }
          if (combinedValue.length > 0) {
            style[property] = combinedValue;
          }
        } else {
          var _processedValue = (0, _prefixValue2.default)(plugins, property, value, style, prefixMap);
          if (_processedValue) {
            style[property] = _processedValue;
          }
          style = (0, _prefixProperty2.default)(prefixMap, property, style);
        }
      }
      return style;
    };
  }
});
var createPrefixer = unwrapExports(createPrefixer_1);
var backgroundClip_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = backgroundClip2;
  function backgroundClip2(property, value) {
    if (typeof value === "string" && value === "text") {
      return ["-webkit-text", "text"];
    }
  }
});
var backgroundClip = unwrapExports(backgroundClip_1);
var isPrefixedValue_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPrefixedValue;
  var regex = /-webkit-|-moz-|-ms-/;
  function isPrefixedValue(value) {
    return typeof value === "string" && regex.test(value);
  }
  module.exports = exports["default"];
});
unwrapExports(isPrefixedValue_1);
var calc_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = calc2;
  var _isPrefixedValue2 = _interopRequireDefault(isPrefixedValue_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var prefixes2 = ["-webkit-", "-moz-", ""];
  function calc2(property, value) {
    if (typeof value === "string" && !(0, _isPrefixedValue2.default)(value) && value.indexOf("calc(") > -1) {
      return prefixes2.map(function(prefix) {
        return value.replace(/calc\(/g, prefix + "calc(");
      });
    }
  }
});
var calc = unwrapExports(calc_1);
var crossFade_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = crossFade2;
  var _isPrefixedValue2 = _interopRequireDefault(isPrefixedValue_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var prefixes2 = ["-webkit-", ""];
  function crossFade2(property, value) {
    if (typeof value === "string" && !(0, _isPrefixedValue2.default)(value) && value.indexOf("cross-fade(") > -1) {
      return prefixes2.map(function(prefix) {
        return value.replace(/cross-fade\(/g, prefix + "cross-fade(");
      });
    }
  }
});
var crossFade = unwrapExports(crossFade_1);
var cursor_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cursor2;
  var prefixes2 = ["-webkit-", "-moz-", ""];
  var values = {
    "zoom-in": true,
    "zoom-out": true,
    grab: true,
    grabbing: true
  };
  function cursor2(property, value) {
    if (property === "cursor" && values.hasOwnProperty(value)) {
      return prefixes2.map(function(prefix) {
        return prefix + value;
      });
    }
  }
});
var cursor = unwrapExports(cursor_1);
var filter_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = filter2;
  var _isPrefixedValue2 = _interopRequireDefault(isPrefixedValue_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var prefixes2 = ["-webkit-", ""];
  function filter2(property, value) {
    if (typeof value === "string" && !(0, _isPrefixedValue2.default)(value) && value.indexOf("filter(") > -1) {
      return prefixes2.map(function(prefix) {
        return value.replace(/filter\(/g, prefix + "filter(");
      });
    }
  }
});
var filter = unwrapExports(filter_1);
var flex_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = flex2;
  var values = {
    flex: ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex", "flex"],
    "inline-flex": ["-webkit-inline-box", "-moz-inline-box", "-ms-inline-flexbox", "-webkit-inline-flex", "inline-flex"]
  };
  function flex2(property, value) {
    if (property === "display" && values.hasOwnProperty(value)) {
      return values[value];
    }
  }
});
var flex = unwrapExports(flex_1);
var flexboxIE_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = flexboxIE2;
  var alternativeValues = {
    "space-around": "distribute",
    "space-between": "justify",
    "flex-start": "start",
    "flex-end": "end"
  };
  var alternativeProps = {
    alignContent: "msFlexLinePack",
    alignSelf: "msFlexItemAlign",
    alignItems: "msFlexAlign",
    justifyContent: "msFlexPack",
    order: "msFlexOrder",
    flexGrow: "msFlexPositive",
    flexShrink: "msFlexNegative",
    flexBasis: "msFlexPreferredSize"
    // Full expanded syntax is flex-grow | flex-shrink | flex-basis.
  };
  var flexShorthandMappings = {
    auto: "1 1 auto",
    inherit: "inherit",
    initial: "0 1 auto",
    none: "0 0 auto",
    unset: "unset"
  };
  var isUnitlessNumber2 = /^\d+(\.\d+)?$/;
  function flexboxIE2(property, value, style) {
    if (Object.prototype.hasOwnProperty.call(alternativeProps, property)) {
      style[alternativeProps[property]] = alternativeValues[value] || value;
    }
    if (property === "flex") {
      if (Object.prototype.hasOwnProperty.call(flexShorthandMappings, value)) {
        style.msFlex = flexShorthandMappings[value];
        return;
      }
      if (isUnitlessNumber2.test(value)) {
        style.msFlex = value + " 1 0%";
        return;
      }
      var flexValues = value.split(/\s/);
      switch (flexValues.length) {
        case 1:
          style.msFlex = "1 1 " + value;
          return;
        case 2:
          if (isUnitlessNumber2.test(flexValues[1])) {
            style.msFlex = flexValues[0] + " " + flexValues[1] + " 0%";
          } else {
            style.msFlex = flexValues[0] + " 1 " + flexValues[1];
          }
          return;
        default:
          style.msFlex = value;
      }
    }
  }
});
var flexboxIE = unwrapExports(flexboxIE_1);
var flexboxOld_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = flexboxOld2;
  var alternativeValues = {
    "space-around": "justify",
    "space-between": "justify",
    "flex-start": "start",
    "flex-end": "end",
    "wrap-reverse": "multiple",
    wrap: "multiple"
  };
  var alternativeProps = {
    alignItems: "WebkitBoxAlign",
    justifyContent: "WebkitBoxPack",
    flexWrap: "WebkitBoxLines",
    flexGrow: "WebkitBoxFlex"
  };
  function flexboxOld2(property, value, style) {
    if (property === "flexDirection" && typeof value === "string") {
      if (value.indexOf("column") > -1) {
        style.WebkitBoxOrient = "vertical";
      } else {
        style.WebkitBoxOrient = "horizontal";
      }
      if (value.indexOf("reverse") > -1) {
        style.WebkitBoxDirection = "reverse";
      } else {
        style.WebkitBoxDirection = "normal";
      }
    }
    if (alternativeProps.hasOwnProperty(property)) {
      style[alternativeProps[property]] = alternativeValues[value] || value;
    }
  }
});
var flexboxOld = unwrapExports(flexboxOld_1);
var gradient_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = gradient2;
  var _isPrefixedValue2 = _interopRequireDefault(isPrefixedValue_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var prefixes2 = ["-webkit-", "-moz-", ""];
  var values = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/gi;
  function gradient2(property, value) {
    if (typeof value === "string" && !(0, _isPrefixedValue2.default)(value) && values.test(value)) {
      return prefixes2.map(function(prefix) {
        return value.replace(values, function(grad) {
          return prefix + grad;
        });
      });
    }
  }
});
var gradient = unwrapExports(gradient_1);
var grid_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _slicedToArray = /* @__PURE__ */ function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  exports.default = grid2;
  function isSimplePositionValue(value) {
    return typeof value === "number" && !isNaN(value);
  }
  var alignmentValues = ["center", "end", "start", "stretch"];
  var displayValues = {
    "inline-grid": ["-ms-inline-grid", "inline-grid"],
    grid: ["-ms-grid", "grid"]
  };
  var propertyConverters = {
    alignSelf: function alignSelf(value, style) {
      if (alignmentValues.indexOf(value) > -1) {
        style.msGridRowAlign = value;
      }
    },
    gridColumn: function gridColumn(value, style) {
      if (isSimplePositionValue(value)) {
        style.msGridColumn = value;
      } else {
        var _value$split$map = value.split("/").map(function(position2) {
          return +position2;
        }), _value$split$map2 = _slicedToArray(_value$split$map, 2), start = _value$split$map2[0], end = _value$split$map2[1];
        propertyConverters.gridColumnStart(start, style);
        propertyConverters.gridColumnEnd(end, style);
      }
    },
    gridColumnEnd: function gridColumnEnd(value, style) {
      var msGridColumn = style.msGridColumn;
      if (isSimplePositionValue(value) && isSimplePositionValue(msGridColumn)) {
        style.msGridColumnSpan = value - msGridColumn;
      }
    },
    gridColumnStart: function gridColumnStart(value, style) {
      if (isSimplePositionValue(value)) {
        style.msGridColumn = value;
      }
    },
    gridRow: function gridRow(value, style) {
      if (isSimplePositionValue(value)) {
        style.msGridRow = value;
      } else {
        var _value$split$map3 = value.split("/").map(function(position2) {
          return +position2;
        }), _value$split$map4 = _slicedToArray(_value$split$map3, 2), start = _value$split$map4[0], end = _value$split$map4[1];
        propertyConverters.gridRowStart(start, style);
        propertyConverters.gridRowEnd(end, style);
      }
    },
    gridRowEnd: function gridRowEnd(value, style) {
      var msGridRow = style.msGridRow;
      if (isSimplePositionValue(value) && isSimplePositionValue(msGridRow)) {
        style.msGridRowSpan = value - msGridRow;
      }
    },
    gridRowStart: function gridRowStart(value, style) {
      if (isSimplePositionValue(value)) {
        style.msGridRow = value;
      }
    },
    gridTemplateColumns: function gridTemplateColumns(value, style) {
      style.msGridColumns = value;
    },
    gridTemplateRows: function gridTemplateRows(value, style) {
      style.msGridRows = value;
    },
    justifySelf: function justifySelf(value, style) {
      if (alignmentValues.indexOf(value) > -1) {
        style.msGridColumnAlign = value;
      }
    }
  };
  function grid2(property, value, style) {
    if (property === "display" && value in displayValues) {
      return displayValues[value];
    }
    if (property in propertyConverters) {
      var propertyConverter = propertyConverters[property];
      propertyConverter(value, style);
    }
  }
});
var grid = unwrapExports(grid_1);
var imageSet_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = imageSet2;
  var _isPrefixedValue2 = _interopRequireDefault(isPrefixedValue_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var prefixes2 = ["-webkit-", ""];
  function imageSet2(property, value) {
    if (typeof value === "string" && !(0, _isPrefixedValue2.default)(value) && value.indexOf("image-set(") > -1) {
      return prefixes2.map(function(prefix) {
        return value.replace(/image-set\(/g, prefix + "image-set(");
      });
    }
  }
});
var imageSet = unwrapExports(imageSet_1);
var logical_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = logical2;
  var alternativeProps = {
    marginBlockStart: ["WebkitMarginBefore"],
    marginBlockEnd: ["WebkitMarginAfter"],
    marginInlineStart: ["WebkitMarginStart", "MozMarginStart"],
    marginInlineEnd: ["WebkitMarginEnd", "MozMarginEnd"],
    paddingBlockStart: ["WebkitPaddingBefore"],
    paddingBlockEnd: ["WebkitPaddingAfter"],
    paddingInlineStart: ["WebkitPaddingStart", "MozPaddingStart"],
    paddingInlineEnd: ["WebkitPaddingEnd", "MozPaddingEnd"],
    borderBlockStart: ["WebkitBorderBefore"],
    borderBlockStartColor: ["WebkitBorderBeforeColor"],
    borderBlockStartStyle: ["WebkitBorderBeforeStyle"],
    borderBlockStartWidth: ["WebkitBorderBeforeWidth"],
    borderBlockEnd: ["WebkitBorderAfter"],
    borderBlockEndColor: ["WebkitBorderAfterColor"],
    borderBlockEndStyle: ["WebkitBorderAfterStyle"],
    borderBlockEndWidth: ["WebkitBorderAfterWidth"],
    borderInlineStart: ["WebkitBorderStart", "MozBorderStart"],
    borderInlineStartColor: ["WebkitBorderStartColor", "MozBorderStartColor"],
    borderInlineStartStyle: ["WebkitBorderStartStyle", "MozBorderStartStyle"],
    borderInlineStartWidth: ["WebkitBorderStartWidth", "MozBorderStartWidth"],
    borderInlineEnd: ["WebkitBorderEnd", "MozBorderEnd"],
    borderInlineEndColor: ["WebkitBorderEndColor", "MozBorderEndColor"],
    borderInlineEndStyle: ["WebkitBorderEndStyle", "MozBorderEndStyle"],
    borderInlineEndWidth: ["WebkitBorderEndWidth", "MozBorderEndWidth"]
  };
  function logical2(property, value, style) {
    if (Object.prototype.hasOwnProperty.call(alternativeProps, property)) {
      var alternativePropList = alternativeProps[property];
      for (var i = 0, len = alternativePropList.length; i < len; ++i) {
        style[alternativePropList[i]] = value;
      }
    }
  }
});
var logical = unwrapExports(logical_1);
var position_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = position2;
  function position2(property, value) {
    if (property === "position" && value === "sticky") {
      return ["-webkit-sticky", "sticky"];
    }
  }
});
var position = unwrapExports(position_1);
var sizing_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = sizing2;
  var prefixes2 = ["-webkit-", "-moz-", ""];
  var properties = {
    maxHeight: true,
    maxWidth: true,
    width: true,
    height: true,
    columnWidth: true,
    minWidth: true,
    minHeight: true
  };
  var values = {
    "min-content": true,
    "max-content": true,
    "fill-available": true,
    "fit-content": true,
    "contain-floats": true
  };
  function sizing2(property, value) {
    if (properties.hasOwnProperty(property) && values.hasOwnProperty(value)) {
      return prefixes2.map(function(prefix) {
        return prefix + value;
      });
    }
  }
});
var sizing = unwrapExports(sizing_1);
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};
function toHyphenLower(match) {
  return "-" + match.toLowerCase();
}
function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name];
  }
  var hName = name.replace(uppercasePattern, toHyphenLower);
  return cache[name] = msPattern.test(hName) ? "-" + hName : hName;
}
var hyphenateStyleName$1 = Object.freeze({
  default: hyphenateStyleName
});
var _hyphenateStyleName = getCjsExportFromNamespace(hyphenateStyleName$1);
var hyphenateProperty_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = hyphenateProperty;
  var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function hyphenateProperty(property) {
    return (0, _hyphenateStyleName2.default)(property);
  }
  module.exports = exports["default"];
});
unwrapExports(hyphenateProperty_1);
var transition_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = transition2;
  var _hyphenateProperty2 = _interopRequireDefault(hyphenateProperty_1);
  var _isPrefixedValue2 = _interopRequireDefault(isPrefixedValue_1);
  var _capitalizeString2 = _interopRequireDefault(capitalizeString_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var properties = {
    transition: true,
    transitionProperty: true,
    WebkitTransition: true,
    WebkitTransitionProperty: true,
    MozTransition: true,
    MozTransitionProperty: true
  };
  var prefixMapping = {
    Webkit: "-webkit-",
    Moz: "-moz-",
    ms: "-ms-"
  };
  function prefixValue(value, propertyPrefixMap) {
    if ((0, _isPrefixedValue2.default)(value)) {
      return value;
    }
    var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);
    for (var i = 0, len = multipleValues.length; i < len; ++i) {
      var singleValue = multipleValues[i];
      var values = [singleValue];
      for (var property in propertyPrefixMap) {
        var dashCaseProperty = (0, _hyphenateProperty2.default)(property);
        if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== "order") {
          var prefixes2 = propertyPrefixMap[property];
          for (var j = 0, pLen = prefixes2.length; j < pLen; ++j) {
            values.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes2[j]] + dashCaseProperty));
          }
        }
      }
      multipleValues[i] = values.join(",");
    }
    return multipleValues.join(",");
  }
  function transition2(property, value, style, propertyPrefixMap) {
    if (typeof value === "string" && properties.hasOwnProperty(property)) {
      var outputValue = prefixValue(value, propertyPrefixMap);
      var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function(val) {
        return !/-moz-|-ms-/.test(val);
      }).join(",");
      if (property.indexOf("Webkit") > -1) {
        return webkitOutput;
      }
      var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function(val) {
        return !/-webkit-|-ms-/.test(val);
      }).join(",");
      if (property.indexOf("Moz") > -1) {
        return mozOutput;
      }
      style["Webkit" + (0, _capitalizeString2.default)(property)] = webkitOutput;
      style["Moz" + (0, _capitalizeString2.default)(property)] = mozOutput;
      return outputValue;
    }
  }
});
var transition = unwrapExports(transition_1);
var w = ["Webkit"];
var m = ["Moz"];
var ms = ["ms"];
var wm = ["Webkit", "Moz"];
var wms = ["Webkit", "ms"];
var wmms = ["Webkit", "Moz", "ms"];
var staticData = {
  plugins: [backgroundClip, calc, crossFade, cursor, filter, flex, flexboxIE, flexboxOld, gradient, grid, imageSet, logical, position, sizing, transition],
  prefixMap: {
    "transform": wms,
    "transformOrigin": wms,
    "transformOriginX": wms,
    "transformOriginY": wms,
    "backfaceVisibility": w,
    "perspective": w,
    "perspectiveOrigin": w,
    "transformStyle": w,
    "transformOriginZ": w,
    "animation": w,
    "animationDelay": w,
    "animationDirection": w,
    "animationFillMode": w,
    "animationDuration": w,
    "animationIterationCount": w,
    "animationName": w,
    "animationPlayState": w,
    "animationTimingFunction": w,
    "appearance": wm,
    "userSelect": wmms,
    "fontKerning": w,
    "textEmphasisPosition": w,
    "textEmphasis": w,
    "textEmphasisStyle": w,
    "textEmphasisColor": w,
    "boxDecorationBreak": w,
    "clipPath": w,
    "maskImage": w,
    "maskMode": w,
    "maskRepeat": w,
    "maskPosition": w,
    "maskClip": w,
    "maskOrigin": w,
    "maskSize": w,
    "maskComposite": w,
    "mask": w,
    "maskBorderSource": w,
    "maskBorderMode": w,
    "maskBorderSlice": w,
    "maskBorderWidth": w,
    "maskBorderOutset": w,
    "maskBorderRepeat": w,
    "maskBorder": w,
    "maskType": w,
    "textDecorationStyle": wm,
    "textDecorationSkip": wm,
    "textDecorationLine": wm,
    "textDecorationColor": wm,
    "filter": w,
    "fontFeatureSettings": wm,
    "breakAfter": wmms,
    "breakBefore": wmms,
    "breakInside": wmms,
    "columnCount": wm,
    "columnFill": wm,
    "columnGap": wm,
    "columnRule": wm,
    "columnRuleColor": wm,
    "columnRuleStyle": wm,
    "columnRuleWidth": wm,
    "columns": wm,
    "columnSpan": wm,
    "columnWidth": wm,
    "writingMode": wms,
    "flex": wms,
    "flexBasis": w,
    "flexDirection": wms,
    "flexGrow": w,
    "flexFlow": wms,
    "flexShrink": w,
    "flexWrap": wms,
    "alignContent": w,
    "alignItems": w,
    "alignSelf": w,
    "justifyContent": w,
    "order": w,
    "transitionDelay": w,
    "transitionDuration": w,
    "transitionProperty": w,
    "transitionTimingFunction": w,
    "backdropFilter": w,
    "scrollSnapType": wms,
    "scrollSnapPointsX": wms,
    "scrollSnapPointsY": wms,
    "scrollSnapDestination": wms,
    "scrollSnapCoordinate": wms,
    "shapeImageThreshold": w,
    "shapeImageMargin": w,
    "shapeImageOutside": w,
    "hyphens": wmms,
    "flowInto": wms,
    "flowFrom": wms,
    "regionFragment": wms,
    "textOrientation": w,
    "boxSizing": m,
    "textAlignLast": m,
    "tabSize": m,
    "wrapFlow": ms,
    "wrapThrough": ms,
    "wrapMargin": ms,
    "touchAction": ms,
    "textSizeAdjust": wms,
    "borderImage": w,
    "borderImageOutset": w,
    "borderImageRepeat": w,
    "borderImageSlice": w,
    "borderImageSource": w,
    "borderImageWidth": w
  }
};
var prefixAll = createPrefixer(staticData);
var defaultSelectorHandlers = [
  // Handle pseudo-selectors, like :hover and :nth-child(3n)
  function pseudoSelectors(selector, baseSelector, generateSubtreeStyles) {
    if (selector[0] !== ":") {
      return null;
    }
    return generateSubtreeStyles(baseSelector + selector);
  },
  // Handle media queries (or font-faces)
  function mediaQueries(selector, baseSelector, generateSubtreeStyles) {
    if (selector[0] !== "@") {
      return null;
    }
    var generated = generateSubtreeStyles(baseSelector);
    return ["".concat(selector, "{").concat(generated.join(""), "}")];
  }
];
var generateCSS = function generateCSS2(selector, styleTypes, selectorHandlers, stringHandlers2, useImportant2) {
  var merged = new OrderedElements();
  for (var i = 0; i < styleTypes.length; i++) {
    merged.addStyleType(styleTypes[i]);
  }
  var plainDeclarations = new OrderedElements();
  var generatedStyles = [];
  merged.forEach(function(val, key) {
    var foundHandler = selectorHandlers.some(function(handler) {
      var result = handler(key, selector, function(newSelector) {
        return generateCSS2(newSelector, [val], selectorHandlers, stringHandlers2, useImportant2);
      });
      if (result != null) {
        if (Array.isArray(result)) {
          generatedStyles.push.apply(generatedStyles, _toConsumableArray(result));
        } else {
          console.warn("WARNING: Selector handlers should return an array of rules.Returning a string containing multiple rules is deprecated.", handler);
          generatedStyles.push("@media all {".concat(result, "}"));
        }
        return true;
      }
    });
    if (!foundHandler) {
      plainDeclarations.set(key, val, true);
    }
  });
  var generatedRuleset = generateCSSRuleset(selector, plainDeclarations, stringHandlers2, useImportant2, selectorHandlers);
  if (generatedRuleset) {
    generatedStyles.unshift(generatedRuleset);
  }
  return generatedStyles;
};
var runStringHandlers = function runStringHandlers2(declarations, stringHandlers2, selectorHandlers) {
  if (!stringHandlers2) {
    return;
  }
  var stringHandlerKeys = Object.keys(stringHandlers2);
  for (var i = 0; i < stringHandlerKeys.length; i++) {
    var key = stringHandlerKeys[i];
    if (declarations.has(key)) {
      declarations.set(
        key,
        stringHandlers2[key](declarations.get(key), selectorHandlers),
        // Preserve order here, since we are really replacing an
        // unprocessed style with a processed style, not overriding an
        // earlier style
        false
      );
    }
  }
};
var transformRule = function transformRule2(key, value, transformValue) {
  return (
    /* : string */
    "".concat(kebabifyStyleName(key), ":").concat(transformValue(key, value), ";")
  );
};
var arrayToObjectKeysReducer = function arrayToObjectKeysReducer2(acc, val) {
  acc[val] = true;
  return acc;
};
var generateCSSRuleset = function generateCSSRuleset2(selector, declarations, stringHandlers2, useImportant2, selectorHandlers) {
  runStringHandlers(declarations, stringHandlers2, selectorHandlers);
  var originalElements = Object.keys(declarations.elements).reduce(arrayToObjectKeysReducer, /* @__PURE__ */ Object.create(null));
  var prefixedElements = prefixAll(declarations.elements);
  var elementNames = Object.keys(prefixedElements);
  if (elementNames.length !== declarations.keyOrder.length) {
    for (var i = 0; i < elementNames.length; i++) {
      if (!originalElements[elementNames[i]]) {
        var originalStyle = void 0;
        if (elementNames[i][0] === "W") {
          originalStyle = elementNames[i][6].toLowerCase() + elementNames[i].slice(7);
        } else if (elementNames[i][1] === "o") {
          originalStyle = elementNames[i][3].toLowerCase() + elementNames[i].slice(4);
        } else {
          originalStyle = elementNames[i][2].toLowerCase() + elementNames[i].slice(3);
        }
        if (originalStyle && originalElements[originalStyle]) {
          var originalIndex = declarations.keyOrder.indexOf(originalStyle);
          declarations.keyOrder.splice(originalIndex, 0, elementNames[i]);
        } else {
          declarations.keyOrder.unshift(elementNames[i]);
        }
      }
    }
  }
  var transformValue = useImportant2 === false ? stringifyValue : stringifyAndImportantifyValue;
  var rules = [];
  for (var _i = 0; _i < declarations.keyOrder.length; _i++) {
    var key = declarations.keyOrder[_i];
    var value = prefixedElements[key];
    if (Array.isArray(value)) {
      for (var j = 0; j < value.length; j++) {
        rules.push(transformRule(key, value[j], transformValue));
      }
    } else {
      rules.push(transformRule(key, value, transformValue));
    }
  }
  if (rules.length) {
    return "".concat(selector, "{").concat(rules.join(""), "}");
  } else {
    return "";
  }
};
var styleTag = null;
var injectStyleTag = function injectStyleTag2(cssRules) {
  if (styleTag == null) {
    styleTag = document.querySelector("style[data-aphrodite]");
    if (styleTag == null) {
      var head = document.head || document.getElementsByTagName("head")[0];
      styleTag = document.createElement("style");
      styleTag.type = "text/css";
      styleTag.setAttribute("data-aphrodite", "");
      head.appendChild(styleTag);
    }
  }
  var sheet = styleTag.styleSheet || styleTag.sheet;
  if (sheet.insertRule) {
    var numRules = sheet.cssRules.length;
    cssRules.forEach(function(rule) {
      try {
        sheet.insertRule(rule, numRules);
        numRules += 1;
      } catch (e) {
      }
    });
  } else {
    styleTag.innerText = (styleTag.innerText || "") + cssRules.join("");
  }
};
var stringHandlers = {
  // With fontFamily we look for objects that are passed in and interpret
  // them as @font-face rules that we need to inject. The value of fontFamily
  // can either be a string (as normal), an object (a single font face), or
  // an array of objects and strings.
  fontFamily: function fontFamily(val) {
    if (Array.isArray(val)) {
      var nameMap = {};
      val.forEach(function(v) {
        nameMap[fontFamily(v)] = true;
      });
      return Object.keys(nameMap).join(",");
    } else if (_typeof(val) === "object") {
      injectStyleOnce(val.src, "@font-face", [val], false);
      return '"'.concat(val.fontFamily, '"');
    } else {
      return val;
    }
  },
  // With animationName we look for an object that contains keyframes and
  // inject them as an `@keyframes` block, returning a uniquely generated
  // name. The keyframes object should look like
  //  animationName: {
  //    from: {
  //      left: 0,
  //      top: 0,
  //    },
  //    '50%': {
  //      left: 15,
  //      top: 5,
  //    },
  //    to: {
  //      left: 20,
  //      top: 20,
  //    }
  //  }
  // TODO(emily): `stringHandlers` doesn't let us rename the key, so I have
  // to use `animationName` here. Improve that so we can call this
  // `animation` instead of `animationName`.
  animationName: function animationName(val, selectorHandlers) {
    if (Array.isArray(val)) {
      return val.map(function(v) {
        return animationName(v, selectorHandlers);
      }).join(",");
    } else if (_typeof(val) === "object") {
      var name = "keyframe_".concat(hashObject(val));
      var finalVal = "@keyframes ".concat(name, "{");
      if (val instanceof OrderedElements) {
        val.forEach(function(valVal, valKey) {
          finalVal += generateCSS(valKey, [valVal], selectorHandlers, stringHandlers, false).join("");
        });
      } else {
        Object.keys(val).forEach(function(key) {
          finalVal += generateCSS(key, [val[key]], selectorHandlers, stringHandlers, false).join("");
        });
      }
      finalVal += "}";
      injectGeneratedCSSOnce(name, [finalVal]);
      return name;
    } else {
      return val;
    }
  }
};
var alreadyInjected = {};
var injectionBuffer = [];
var isBuffering = false;
var injectGeneratedCSSOnce = function injectGeneratedCSSOnce2(key, generatedCSS) {
  var _injectionBuffer;
  if (alreadyInjected[key]) {
    return;
  }
  if (!isBuffering) {
    if (typeof document === "undefined") {
      throw new Error("Cannot automatically buffer without a document");
    }
    isBuffering = true;
    (0, import_asap.default)(flushToStyleTag);
  }
  (_injectionBuffer = injectionBuffer).push.apply(_injectionBuffer, _toConsumableArray(generatedCSS));
  alreadyInjected[key] = true;
};
var injectStyleOnce = function injectStyleOnce2(key, selector, definitions, useImportant2) {
  var selectorHandlers = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
  if (alreadyInjected[key]) {
    return;
  }
  var generated = generateCSS(selector, definitions, selectorHandlers, stringHandlers, useImportant2);
  injectGeneratedCSSOnce(key, generated);
};
var reset = function reset2() {
  injectionBuffer = [];
  alreadyInjected = {};
  isBuffering = false;
  styleTag = null;
};
var resetInjectedStyle = function resetInjectedStyle2(key) {
  delete alreadyInjected[key];
};
var getBufferedStyles = function getBufferedStyles2() {
  return injectionBuffer;
};
var startBuffering = function startBuffering2() {
  if (isBuffering) {
    throw new Error("Cannot buffer while already buffering");
  }
  isBuffering = true;
};
var flushToArray = function flushToArray2() {
  isBuffering = false;
  var ret = injectionBuffer;
  injectionBuffer = [];
  return ret;
};
var flushToString = function flushToString2() {
  return flushToArray().join("");
};
var flushToStyleTag = function flushToStyleTag2() {
  var cssRules = flushToArray();
  if (cssRules.length > 0) {
    injectStyleTag(cssRules);
  }
};
var getRenderedClassNames = function getRenderedClassNames2() {
  return Object.keys(alreadyInjected);
};
var addRenderedClassNames = function addRenderedClassNames2(classNames) {
  classNames.forEach(function(className) {
    alreadyInjected[className] = true;
  });
};
var isValidStyleDefinition = function isValidStyleDefinition2(def) {
  return "_definition" in def && "_name" in def && "_len" in def;
};
var processStyleDefinitions = function processStyleDefinitions2(styleDefinitions, classNameBits, definitionBits, length) {
  for (var i = 0; i < styleDefinitions.length; i += 1) {
    if (styleDefinitions[i]) {
      if (Array.isArray(styleDefinitions[i])) {
        length += processStyleDefinitions2(styleDefinitions[i], classNameBits, definitionBits, length);
      } else if (isValidStyleDefinition(styleDefinitions[i])) {
        classNameBits.push(styleDefinitions[i]._name);
        definitionBits.push(styleDefinitions[i]._definition);
        length += styleDefinitions[i]._len;
      } else {
        throw new Error("Invalid Style Definition: Styles should be defined using the StyleSheet.create method.");
      }
    }
  }
  return length;
};
var injectAndGetClassName = function injectAndGetClassName2(useImportant2, styleDefinitions, selectorHandlers) {
  var classNameBits = [];
  var definitionBits = [];
  var length = processStyleDefinitions(styleDefinitions, classNameBits, definitionBits, 0);
  if (classNameBits.length === 0) {
    return "";
  }
  var className;
  if (false) {
    className = classNameBits.length === 1 ? "_".concat(classNameBits[0]) : "_".concat(hashString(classNameBits.join())).concat((length % 36).toString(36));
  } else {
    className = classNameBits.join("-o_O-");
  }
  injectStyleOnce(className, ".".concat(className), definitionBits, useImportant2, selectorHandlers);
  return className;
};
var unminifiedHashFn = function unminifiedHashFn2(str, key) {
  return "".concat(key, "_").concat(hashString(str));
};
var initialHashFn = function initialHashFn2() {
  return false ? hashString : unminifiedHashFn;
};
var hashFn = initialHashFn();
var StyleSheet = {
  create: function create(sheetDefinition) {
    var mappedSheetDefinition = {};
    var keys = Object.keys(sheetDefinition);
    for (var i = 0; i < keys.length; i += 1) {
      var key = keys[i];
      var val = sheetDefinition[key];
      var stringVal = JSON.stringify(val);
      mappedSheetDefinition[key] = {
        _len: stringVal.length,
        _name: hashFn(stringVal, key),
        _definition: val
      };
    }
    return mappedSheetDefinition;
  },
  rehydrate: function rehydrate() {
    var renderedClassNames = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    addRenderedClassNames(renderedClassNames);
  }
};
var StyleSheetServer = typeof window !== "undefined" ? null : {
  renderStatic: function renderStatic(renderFunc) {
    reset();
    startBuffering();
    var html = renderFunc();
    var cssContent = flushToString();
    return {
      html,
      css: {
        content: cssContent,
        renderedClassNames: getRenderedClassNames()
      }
    };
  }
};
var StyleSheetTestUtils = false ? null : {
  /**
  * Prevent styles from being injected into the DOM.
  *
  * This is useful in situations where you'd like to test rendering UI
  * components which use Aphrodite without any of the side-effects of
  * Aphrodite happening. Particularly useful for testing the output of
  * components when you have no DOM, e.g. testing in Node without a fake DOM.
  *
  * Should be paired with a subsequent call to
  * clearBufferAndResumeStyleInjection.
  */
  suppressStyleInjection: function suppressStyleInjection() {
    reset();
    startBuffering();
  },
  /**
  * Opposite method of preventStyleInject.
  */
  clearBufferAndResumeStyleInjection: function clearBufferAndResumeStyleInjection() {
    reset();
  },
  /**
  * Returns a string of buffered styles which have not been flushed
  *
  * @returns {string}  Buffer of styles which have not yet been flushed.
  */
  getBufferedStyles: function getBufferedStyles$1() {
    return getBufferedStyles();
  }
};
function makeExports(useImportant2) {
  var selectorHandlers = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultSelectorHandlers;
  return {
    StyleSheet: _objectSpread({}, StyleSheet, {
      /**
       * Returns a version of the exports of Aphrodite (i.e. an object
       * with `css` and `StyleSheet` properties) which have some
       * extensions included.
       *
       * @param {Array.<Object>} extensions: An array of extensions to
       *     add to this instance of Aphrodite. Each object should have a
       *     single property on it, defining which kind of extension to
       *     add.
       * @param {SelectorHandler} [extensions[].selectorHandler]: A
       *     selector handler extension. See `defaultSelectorHandlers` in
       *     generate.js.
       *
       * @returns {Object} An object containing the exports of the new
       *     instance of Aphrodite.
       */
      extend: function extend(extensions) {
        var extensionSelectorHandlers = extensions.map(function(extension) {
          return extension.selectorHandler;
        }).filter(function(handler) {
          return handler;
        });
        return makeExports(useImportant2, selectorHandlers.concat(extensionSelectorHandlers));
      }
    }),
    StyleSheetServer,
    StyleSheetTestUtils,
    minify: function minify2(shouldMinify) {
      hashFn = shouldMinify ? hashString : unminifiedHashFn;
    },
    css: function css2() {
      for (var _len = arguments.length, styleDefinitions = new Array(_len), _key = 0; _key < _len; _key++) {
        styleDefinitions[_key] = arguments[_key];
      }
      return injectAndGetClassName(useImportant2, styleDefinitions, selectorHandlers);
    },
    flushToStyleTag,
    injectAndGetClassName,
    defaultSelectorHandlers,
    reset,
    resetInjectedStyle
  };
}

// node_modules/aphrodite/es/index.js
var import_string_hash2 = __toESM(require_string_hash());
var import_asap2 = __toESM(require_browser_asap());
var useImportant = true;
var Aphrodite = makeExports(useImportant);
var StyleSheet2 = Aphrodite.StyleSheet;
var StyleSheetServer2 = Aphrodite.StyleSheetServer;
var StyleSheetTestUtils2 = Aphrodite.StyleSheetTestUtils;
var css = Aphrodite.css;
var minify = Aphrodite.minify;
var flushToStyleTag3 = Aphrodite.flushToStyleTag;
var injectAndGetClassName3 = Aphrodite.injectAndGetClassName;
var defaultSelectorHandlers2 = Aphrodite.defaultSelectorHandlers;
var reset3 = Aphrodite.reset;
var resetInjectedStyle3 = Aphrodite.resetInjectedStyle;
export {
  StyleSheet2 as StyleSheet,
  StyleSheetServer2 as StyleSheetServer,
  StyleSheetTestUtils2 as StyleSheetTestUtils,
  css,
  defaultSelectorHandlers2 as defaultSelectorHandlers,
  flushToStyleTag3 as flushToStyleTag,
  injectAndGetClassName3 as injectAndGetClassName,
  minify,
  reset3 as reset,
  resetInjectedStyle3 as resetInjectedStyle
};
//# sourceMappingURL=aphrodite.js.map
